namespace jacdac {
    // Service Jacscript Manager constants
    export const SRV_JACSCRIPT_MANAGER = 0x1134ea2b

    export const enum JacscriptManagerMessageFlags { // uint8_t
        //% block="to be continued"
        ToBeContinued = 0x1,
    }

    export const enum JacscriptManagerCmd {
        /**
         * Argument: bytecode_size B uint32_t. Open pipe for streaming in the bytecode of the program. The size of the bytecode has to be declared upfront.
         * To clear the program, use `bytecode_size == 0`.
         * The bytecode is streamed over regular pipe data packets.
         * The bytecode shall be fully written into flash upon closing the pipe.
         * If `autostart` is true, the program will start after being deployed.
         * The data payloads, including the last one, should have a size that is a multiple of 32 bytes.
         * Thus, the initial bytecode_size also needs to be a multiple of 32.
         *
         * ```
         * const [bytecodeSize] = jdunpack<[number]>(buf, "u32")
         * ```
         */
        DeployBytecode = 0x80,

        /**
         * report DeployBytecode
         * ```
         * const [bytecodePort] = jdunpack<[number]>(buf, "u16")
         * ```
         */

        /**
         * Argument: bytecode pipe (bytes). Get the current bytecode deployed on device.
         *
         * ```
         * const [bytecode] = jdunpack<[Buffer]>(buf, "b[12]")
         * ```
         */
        ReadBytecode = 0x81,

        /**
         * Generated by `console.log()` calls from Jacscript program.
         * The counter starts at `0`, increments by `1` for each packet and wraps around.
         * It can be used to detect if some messages are missing.
         * If message is too long to fit in a single packet, it will be fragmented (this is not implemented yet).
         * In a fragmented message, all packets except for the last one have `ToBeContinued` flag set.
         * Note that `counter` field will increase in each fragment.
         * `log_message` reports are only sent when `logging == true`.
         *
         * ```
         * const [counter, flags, message] = jdunpack<[number, jacdac.JacscriptManagerMessageFlags, string]>(buf, "u8 u8 s")
         * ```
         */
        LogMessage = 0x82,
    }

    /**
     * pipe_report Bytecode
     * ```
     * const [data] = jdunpack<[Buffer]>(buf, "b")
     * ```
     */

    export const enum JacscriptManagerReg {
        /**
         * Read-write bool (uint8_t). Indicates if the program is currently running.
         * To restart the program, stop it (write `0`), read back the register to make sure it's stopped,
         * start it, and read back.
         *
         * ```
         * const [running] = jdunpack<[number]>(buf, "u8")
         * ```
         */
        Running = 0x80,

        /**
         * Read-write bool (uint8_t). Indicates wheather the program should be re-started upon `reboot()` or `panic()`.
         * Defaults to `true`.
         *
         * ```
         * const [autostart] = jdunpack<[number]>(buf, "u8")
         * ```
         */
        Autostart = 0x81,

        /**
         * Read-write bool (uint8_t). `log_message` reports are only sent when this is `true`.
         * It defaults to `false`.
         *
         * ```
         * const [logging] = jdunpack<[number]>(buf, "u8")
         * ```
         */
        Logging = 0x82,

        /**
         * Read-only uint32_t. The size of current program.
         *
         * ```
         * const [programSize] = jdunpack<[number]>(buf, "u32")
         * ```
         */
        ProgramSize = 0x180,

        /**
         * Read-only uint32_t. Return FNV1A hash of the current bytecode.
         *
         * ```
         * const [programHash] = jdunpack<[number]>(buf, "u32")
         * ```
         */
        ProgramHash = 0x181,
    }

    export const enum JacscriptManagerEvent {
        /**
         * Emitted when the program calls `panic(panic_code)` or `reboot()` (`panic_code == 0` in that case).
         * The byte offset in byte code of the call is given in `program_counter`.
         * The program will restart immediately when `panic_code == 0` or in a few seconds otherwise.
         *
         * ```
         * const [panicCode, programCounter] = jdunpack<[number, number]>(buf, "u32 u32")
         * ```
         */
        //% block="program panic"
        ProgramPanic = 0x80,

        /**
         * Emitted after bytecode of the program has changed.
         */
        //% block="program change"
        ProgramChange = 0x3,
    }
}
