{
  "JDDimension.Strength|block": "strength",
  "JDDimension.X|block": "x",
  "JDDimension.Y|block": "y",
  "JDDimension.Z|block": "z",
  "control|block": "control",
  "jacdac.BaseCmd.CommandNotImplemented": "This report may be emitted by a server in response to a command (action or register operation)\nthat it does not understand.\nThe `service_command` and `packet_crc` fields are copied from the command packet that was unhandled.\nNote that it's possible to get an ACK, followed by such an error report.\n* ```\nconst [serviceCommand, packetCrc] = jdunpack<[number, number]>(buf, \"u16 u16\")\n```",
  "jacdac.BaseEvent.StatusCodeChanged": "Notifies that the status code of the service changed.\n* ```\nconst [code, vendorCode] = jdunpack<[number, number]>(buf, \"u16 u16\")\n```",
  "jacdac.BaseEvent.StatusCodeChanged|block": "status code changed",
  "jacdac.BaseReg.ClientVariant": "Read-write string (bytes). An optional register in the format of a URL query string where the client can provide hints how\nthe device twin should be rendered. If the register is not implemented, the client library can simulate the register client side.\n* ```\nconst [clientVariant] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.BaseReg.InstanceName": "Constant string (bytes). A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).\n* ```\nconst [instanceName] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.BaseReg.StatusCode": "Reports the current state or error status of the device. ``code`` is a standardized value from\nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.\n* ```\nconst [code, vendorCode] = jdunpack<[number, number]>(buf, \"u16 u16\")\n```",
  "jacdac.BootloaderCmd.Info": "No args. The `service_class` is always `0x1ffa9948`. The `product_identifier` identifies the kind of firmware\nthat \"fits\" this device.",
  "jacdac.BootloaderCmd.PageData": "report SetSession\n```\nconst [sessionId] = jdunpack<[number]>(buf, \"u32\")\n```\n\nUse to send flashing data. A physical page is split into `chunk_max + 1` chunks, where `chunk_no = 0 ... chunk_max`.\nEach chunk is stored at `page_address + page_offset`. `page_address` has to be equal in all chunks,\nand is included in response.\nOnly the last chunk causes writing to flash and elicits response.\n* ```\nconst [pageAddress, pageOffset, chunkNo, chunkMax, sessionId, pageData] = jdunpack<[number, number, number, number, number, Buffer]>(buf, \"u32 u16 u8 u8 u32 x[4] x[4] x[4] x[4] b[208]\")\n```",
  "jacdac.BootloaderCmd.SetSession": "report Info\n```\nconst [serviceClass, pageSize, flashableSize, productIdentifier] = jdunpack<[number, number, number, number]>(buf, \"u32 u32 u32 u32\")\n```\n\nArgument: session_id uint32_t. The flashing server should generate a random id, and use this command to set it.\n* ```\nconst [sessionId] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.BootloaderError.InvalidPageOffset|block": "invalid page offset",
  "jacdac.BootloaderError.NoError|block": "no error",
  "jacdac.BootloaderError.NotPageAligned|block": "not page aligned",
  "jacdac.BootloaderError.OutOfFlashableRange|block": "out of flashable range",
  "jacdac.BootloaderError.PacketTooSmall|block": "packet too small",
  "jacdac.BridgeReg.Enabled": "Read-write bool (uint8_t). Enables or disables the bridge.\n* ```\nconst [enabled] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.Client.isConnected|block": "%client connected",
  "jacdac.Client.onConnectionChanged|block": "on %client $state",
  "jacdac.ClientConnectionState.Connected|block": "connected",
  "jacdac.ClientConnectionState.Disconnected|block": "disconnected",
  "jacdac.ControlAnnounceFlags.IsClient|block": "is client",
  "jacdac.ControlAnnounceFlags.RestartCounter1|block": "restart counter1",
  "jacdac.ControlAnnounceFlags.RestartCounter2|block": "restart counter2",
  "jacdac.ControlAnnounceFlags.RestartCounter4|block": "restart counter4",
  "jacdac.ControlAnnounceFlags.RestartCounter8|block": "restart counter8",
  "jacdac.ControlAnnounceFlags.RestartCounterSteady|block": "restart counter steady",
  "jacdac.ControlAnnounceFlags.StatusLightMono|block": "status light mono",
  "jacdac.ControlAnnounceFlags.StatusLightNone|block": "status light none",
  "jacdac.ControlAnnounceFlags.StatusLightRgbFade|block": "status light rgb fade",
  "jacdac.ControlAnnounceFlags.StatusLightRgbNoFade|block": "status light rgb no fade",
  "jacdac.ControlAnnounceFlags.SupportsACK|block": "supports ack",
  "jacdac.ControlAnnounceFlags.SupportsBroadcast|block": "supports broadcast",
  "jacdac.ControlAnnounceFlags.SupportsFrames|block": "supports frames",
  "jacdac.ControlAnnounceFlags.SupportsReliableCommands|block": "supports reliable commands",
  "jacdac.ControlCmd.FloodPing": "The device will respond `num_responses` times, as fast as it can, setting the `counter` field in the report\nto `start_counter`, then `start_counter + 1`, ..., and finally `start_counter + num_responses - 1`.\nThe `dummy_payload` is `size` bytes long and contains bytes `0, 1, 2, ...`.\n* ```\nconst [numResponses, startCounter, size] = jdunpack<[number, number, number]>(buf, \"u32 u32 u8\")\n```",
  "jacdac.ControlCmd.Identify": "No args. Blink the status LED (262ms on, 262ms off, four times, with the blue LED) or otherwise draw user's attention to device with no status light.\nFor devices with status light (this can be discovered in the announce flags), the client should\nsend the sequence of status light command to generate the identify animation.",
  "jacdac.ControlCmd.Noop": "report Services\n```\nconst [flags, packetCount, serviceClass] = jdunpack<[jacdac.ControlAnnounceFlags, number, number[]]>(buf, \"u16 u8 x[1] u32[]\")\n```\n\nNo args. Do nothing. Always ignored. Can be used to test ACKs.",
  "jacdac.ControlCmd.Proxy": "No args. Force client device into proxy mode.",
  "jacdac.ControlCmd.ReliableCommands": "Argument: seed uint32_t. This opens a pipe to the device to provide an alternative, reliable transport of actions\n(and possibly other commands).\nThe commands are wrapped as pipe data packets.\nMultiple invocations of this command with the same `seed` are dropped\n(and thus the command is not `unique`); otherwise `seed` carries no meaning\nand should be set to a random value by the client.\nNote that while the commands sends this way are delivered exactly once, the\nresponses might get lost.\n* ```\nconst [seed] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ControlCmd.Reset": "No args. Reset device. ACK may or may not be sent.",
  "jacdac.ControlCmd.Services": "No args. The `restart_counter` is computed from the `flags & RestartCounterSteady`, starts at `0x1` and increments by one until it reaches `0xf`, then it stays at `0xf`.\nIf this number ever goes down, it indicates that the device restarted.\n`service_class` indicates class identifier for each service index (service index `0` is always control, so it's\nskipped in this enumeration).\n`packet_count` indicates the number of reports sent by the current device since last announce,\nincluding the current announce packet (it is always 0 if this feature is not supported).\nThe command form can be used to induce report, which is otherwise broadcast every 500ms.",
  "jacdac.ControlCmd.SetStatusLight": "report FloodPing\n```\nconst [counter, dummyPayload] = jdunpack<[number, Buffer]>(buf, \"u32 b\")\n```\n\nInitiates a color transition of the status light from its current color to the one specified.\nThe transition will complete in about `512 / speed` frames\n(each frame is currently 100ms, so speed of `51` is about 1 second and `26` 0.5 second).\nAs a special case, if speed is `0` the transition is immediate.\nIf MCU is not capable of executing transitions, it can consider `speed` to be always `0`.\nIf a monochrome LEDs is fitted, the average value of `red`, `green`, `blue` is used.\nIf intensity of a monochrome LED cannot be controlled, any value larger than `0` should be considered\non, and `0` (for all three channels) should be considered off.\n* ```\nconst [toRed, toGreen, toBlue, speed] = jdunpack<[number, number, number, number]>(buf, \"u8 u8 u8 u8\")\n```",
  "jacdac.ControlCmd.Standby": "report ReliableCommands\n```\nconst [commands] = jdunpack<[Buffer]>(buf, \"b[12]\")\n```\n\nArgument: duration ms uint32_t. Attempt to put devices into lowest power sleep mode for a specified time - most likely involving a full reset on wake-up.\n* ```\nconst [duration] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ControlReg.BootloaderProductIdentifier": "Constant uint32_t. Typically the same as `product_identifier` unless device was flashed by hand; the bootloader will respond to that code.\n* ```\nconst [bootloaderProductIdentifier] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ControlReg.DeviceDescription": "Constant string (bytes). Identifies the type of hardware (eg., ACME Corp. Servo X-42 Rev C)\n* ```\nconst [deviceDescription] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ControlReg.FirmwareVersion": "Constant string (bytes). A string describing firmware version; typically semver.\n* ```\nconst [firmwareVersion] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ControlReg.McuTemperature": "Read-only °C int16_t. MCU temperature in degrees Celsius (approximate).\n* ```\nconst [mcuTemperature] = jdunpack<[number]>(buf, \"i16\")\n```",
  "jacdac.ControlReg.ProductIdentifier": "Constant uint32_t. A numeric code for the string above; used to identify firmware images and devices.\n* ```\nconst [productIdentifier] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ControlReg.ResetIn": "Read-write μs uint32_t. When set to value other than `0`, it asks the device to reset after specified number of microseconds.\nThis is typically used to implement watchdog functionality, where a brain device sets `reset_in` to\nsay 1.6s every 0.5s.\n* ```\nconst [resetIn] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ControlReg.Uptime": "Read-only μs uint64_t. Number of microseconds since boot.\n* ```\nconst [uptime] = jdunpack<[number]>(buf, \"u64\")\n```",
  "jacdac.LoggerCmd.Debug": "Argument: message string (bytes). Report a message.\n* ```\nconst [message] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.LoggerCmd.Error": "Argument: message string (bytes). Report a message.\n* ```\nconst [message] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.LoggerCmd.Log": "Argument: message string (bytes). Report a message.\n* ```\nconst [message] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.LoggerCmd.Warn": "Argument: message string (bytes). Report a message.\n* ```\nconst [message] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.LoggerPriority.Debug|block": "debug",
  "jacdac.LoggerPriority.Error|block": "error",
  "jacdac.LoggerPriority.Log|block": "log",
  "jacdac.LoggerPriority.Silent|block": "silent",
  "jacdac.LoggerPriority.Warning|block": "warning",
  "jacdac.LoggerReg.MinPriority": "Read-write Priority (uint8_t). Messages with level lower than this won't be emitted. The default setting may vary.\nLoggers should revert this to their default setting if the register has not been\nupdated in 3000ms, and also keep the lowest setting they have seen in the last 1500ms.\nThus, clients should write this register every 1000ms and ignore messages which are\ntoo verbose for them.\n* ```\nconst [minPriority] = jdunpack<[jacdac.LoggerPriority]>(buf, \"u8\")\n```",
  "jacdac.ProtoTestCmd.CBool": "Argument: bo bool (uint8_t). A command to set rw_bool.\n* ```\nconst [bo] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.ProtoTestCmd.CBytes": "Argument: bytes bytes. A command to set rw_string.\n* ```\nconst [bytes] = jdunpack<[Buffer]>(buf, \"b\")\n```",
  "jacdac.ProtoTestCmd.CI32": "Argument: i32 int32_t. A command to set rw_i32.\n* ```\nconst [i32] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.ProtoTestCmd.CI8U8U16I32": "A command to set rw_bytes.\n* ```\nconst [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, \"i8 u8 u16 i32\")\n```",
  "jacdac.ProtoTestCmd.CReportPipe": "Argument: p_bytes pipe (bytes). A command to read the content of rw_bytes, byte per byte, as a pipe.\n* ```\nconst [pBytes] = jdunpack<[Buffer]>(buf, \"b[12]\")\n```",
  "jacdac.ProtoTestCmd.CString": "Argument: str string (bytes). A command to set rw_string.\n* ```\nconst [str] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ProtoTestCmd.CU32": "Argument: u32 uint32_t. A command to set rw_u32.\n* ```\nconst [u32] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ProtoTestCmd.CU8String": "A command to set rw_u8_string.\n* ```\nconst [u8, str] = jdunpack<[number, string]>(buf, \"u8 s\")\n```",
  "jacdac.ProtoTestEvent.EBool": "Argument: bo bool (uint8_t). An event raised when rw_bool is modified\n* ```\nconst [bo] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.ProtoTestEvent.EBool|block": "e bool",
  "jacdac.ProtoTestEvent.EBytes": "Argument: bytes bytes. An event raised when rw_bytes is modified\n* ```\nconst [bytes] = jdunpack<[Buffer]>(buf, \"b\")\n```",
  "jacdac.ProtoTestEvent.EBytes|block": "e bytes",
  "jacdac.ProtoTestEvent.EI32": "Argument: i32 int32_t. An event raised when rw_i32 is modified\n* ```\nconst [i32] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.ProtoTestEvent.EI32|block": "e i32",
  "jacdac.ProtoTestEvent.EI8U8U16I32": "An event raised when rw_i8_u8_u16_i32 is modified\n* ```\nconst [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, \"i8 u8 u16 i32\")\n```",
  "jacdac.ProtoTestEvent.EI8U8U16I32|block": "e i8 u8 u16 i32",
  "jacdac.ProtoTestEvent.EString": "Argument: str string (bytes). An event raised when rw_string is modified\n* ```\nconst [str] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ProtoTestEvent.EString|block": "e string",
  "jacdac.ProtoTestEvent.EU32": "Argument: u32 uint32_t. An event raised when rw_u32 is modified\n* ```\nconst [u32] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ProtoTestEvent.EU32|block": "e u32",
  "jacdac.ProtoTestEvent.EU8String": "An event raised when rw_u8_string is modified\n* ```\nconst [u8, str] = jdunpack<[number, string]>(buf, \"u8 s\")\n```",
  "jacdac.ProtoTestEvent.EU8String|block": "e u8 string",
  "jacdac.ProtoTestReg.RoBool": "Read-only bool (uint8_t). A read only bool register. Mirrors rw_bool.\n* ```\nconst [roBool] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.ProtoTestReg.RoBytes": "Read-only bytes. A read only string register. Mirrors ro_bytes.\n* ```\nconst [roBytes] = jdunpack<[Buffer]>(buf, \"b\")\n```",
  "jacdac.ProtoTestReg.RoI32": "Read-only int32_t. A read only i32 register.. Mirrors rw_i32.\n* ```\nconst [roI32] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.ProtoTestReg.RoI8U8U16I32": "A read only i8, u8, u16, i32 register.. Mirrors rw_i8_u8_u16_i32.\n* ```\nconst [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, \"i8 u8 u16 i32\")\n```",
  "jacdac.ProtoTestReg.RoString": "Read-only string (bytes). A read only string register. Mirrors rw_string.\n* ```\nconst [roString] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ProtoTestReg.RoU32": "Read-only uint32_t. A read only u32 register.. Mirrors rw_u32.\n* ```\nconst [roU32] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ProtoTestReg.RoU8String": "A read only u8, string register.. Mirrors rw_u8_string.\n* ```\nconst [u8, str] = jdunpack<[number, string]>(buf, \"u8 s\")\n```",
  "jacdac.ProtoTestReg.RwBool": "Read-write bool (uint8_t). A read write bool register.\n* ```\nconst [rwBool] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.ProtoTestReg.RwBytes": "Read-write bytes. A read write string register.\n* ```\nconst [rwBytes] = jdunpack<[Buffer]>(buf, \"b\")\n```",
  "jacdac.ProtoTestReg.RwI32": "Read-write int32_t. A read write i32 register.\n* ```\nconst [rwI32] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.ProtoTestReg.RwI8U8U16I32": "A read write i8, u8, u16, i32 register.\n* ```\nconst [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, \"i8 u8 u16 i32\")\n```",
  "jacdac.ProtoTestReg.RwString": "Read-write string (bytes). A read write string register.\n* ```\nconst [rwString] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.ProtoTestReg.RwU32": "Read-write uint32_t. A read write u32 register.\n* ```\nconst [rwU32] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.ProtoTestReg.RwU8String": "A read write u8, string register.\n* ```\nconst [u8, str] = jdunpack<[number, string]>(buf, \"u8 s\")\n```",
  "jacdac.RoleManagerCmd.ClearAllRoles": "No args. Remove all role bindings.",
  "jacdac.RoleManagerCmd.ListRoles": "Argument: roles pipe (bytes). List all roles and bindings required by the current program. `device_id` and `service_idx` are `0` if role is unbound.\n* ```\nconst [roles] = jdunpack<[Buffer]>(buf, \"b[12]\")\n```",
  "jacdac.RoleManagerCmd.SetRole": "Set role. Can set to empty to remove role binding.\n* ```\nconst [deviceId, serviceIdx, role] = jdunpack<[Buffer, number, string]>(buf, \"b[8] u8 s\")\n```",
  "jacdac.RoleManagerEvent.Change": "Notifies that role bindings have changed.",
  "jacdac.RoleManagerEvent.Change|block": "change",
  "jacdac.RoleManagerReg.AllRolesAllocated": "Read-only bool (uint8_t). Indicates if all required roles have been allocated to devices.\n* ```\nconst [allRolesAllocated] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.RoleManagerReg.AutoBind": "Read-write bool (uint8_t). Normally, if some roles are unfilled, and there are idle services that can fulfill them,\nthe brain device will assign roles (bind) automatically.\nSuch automatic assignment happens every second or so, and is trying to be smart about\nco-locating roles that share \"host\" (part before first slash),\nas well as reasonably stable assignments.\nOnce user start assigning roles manually using this service, auto-binding should be disabled to avoid confusion.\n* ```\nconst [autoBind] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.SensorReg.StreamingInterval": "Read-write ms uint32_t. Period between packets of data when streaming in milliseconds.\n* ```\nconst [streamingInterval] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SensorReg.StreamingPreferredInterval": "Constant ms uint32_t. Preferred default streaming interval for sensor in milliseconds.\n* ```\nconst [streamingPreferredInterval] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SensorReg.StreamingSamples": "Read-write # uint8_t. Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).\n* ```\nconst [streamingSamples] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.SettingsCmd.Clear": "No args. Clears all keys.",
  "jacdac.SettingsCmd.Delete": "Argument: key string (bytes). Delete a given setting.\n* ```\nconst [key] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.SettingsCmd.Get": "Argument: key string (bytes). Get the value of given setting. If no such entry exists, the value returned is empty.\n* ```\nconst [key] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.SettingsCmd.List": "Argument: results pipe (bytes). Return keys and values of all settings.\n* ```\nconst [results] = jdunpack<[Buffer]>(buf, \"b[12]\")\n```",
  "jacdac.SettingsCmd.ListKeys": "Argument: results pipe (bytes). Return keys of all settings.\n* ```\nconst [results] = jdunpack<[Buffer]>(buf, \"b[12]\")\n```",
  "jacdac.SettingsCmd.Set": "report Get\n```\nconst [key, value] = jdunpack<[string, Buffer]>(buf, \"z b\")\n```\n\nSet the value of a given setting.\n* ```\nconst [key, value] = jdunpack<[string, Buffer]>(buf, \"z b\")\n```",
  "jacdac.SettingsEvent.Change": "Notifies that some setting have been modified.",
  "jacdac.SettingsEvent.Change|block": "change",
  "jacdac.SystemCmd.Announce": "No args. Enumeration data for control service; service-specific advertisement data otherwise.\nControl broadcasts it automatically every `announce_interval`ms, but other service have to be queried to provide it.",
  "jacdac.SystemCmd.Calibrate": "No args. Request to calibrate a sensor. The report indicates the calibration is done.",
  "jacdac.SystemCmd.CommandNotImplemented": "This report may be emitted by a server in response to a command (action or register operation)\nthat it does not understand.\nThe `service_command` and `packet_crc` fields are copied from the command packet that was unhandled.\nNote that it's possible to get an ACK, followed by such an error report.\n* ```\nconst [serviceCommand, packetCrc] = jdunpack<[number, number]>(buf, \"u16 u16\")\n```",
  "jacdac.SystemCmd.GetRegister": "No args. Registers number `N` is fetched by issuing command `0x1000 | N`.\nThe report format is the same as the format of the register.",
  "jacdac.SystemCmd.SetRegister": "No args. Registers number `N` is set by issuing command `0x2000 | N`, with the format\nthe same as the format of the register.",
  "jacdac.SystemEvent.Active": "Notifies that the service has been activated (eg. button pressed, network connected, etc.)",
  "jacdac.SystemEvent.Active|block": "active",
  "jacdac.SystemEvent.Change": "Notifies that the some state of the service changed.",
  "jacdac.SystemEvent.Change|block": "change",
  "jacdac.SystemEvent.Inactive": "Notifies that the service has been dis-activated.",
  "jacdac.SystemEvent.Inactive|block": "inactive",
  "jacdac.SystemEvent.Neutral": "Notifies that the threshold is back between `low` and `high`.",
  "jacdac.SystemEvent.Neutral|block": "neutral",
  "jacdac.SystemEvent.StatusCodeChanged": "Notifies that the status code of the service changed.\n* ```\nconst [code, vendorCode] = jdunpack<[jacdac.SystemStatusCodes, number]>(buf, \"u16 u16\")\n```",
  "jacdac.SystemEvent.StatusCodeChanged|block": "status code changed",
  "jacdac.SystemReadingThreshold.Active|block": "active",
  "jacdac.SystemReadingThreshold.Inactive|block": "inactive",
  "jacdac.SystemReadingThreshold.Neutral|block": "neutral",
  "jacdac.SystemReg.ActiveThreshold": "Read-write int32_t. Thresholds when reading data gets active and triggers a `active` event.\n* ```\nconst [activeThreshold] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.ClientVariant": "Read-write string (bytes). An optional register in the format of a URL query string where the client can provide hints how\nthe device twin should be rendered. If the register is not implemented, the client library can simulate the register client side.\n* ```\nconst [clientVariant] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.SystemReg.InactiveThreshold": "Read-write int32_t. Threshold when reading data gets inactive and triggers a `inactive`.\n* ```\nconst [inactiveThreshold] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.InstanceName": "Constant string (bytes). A friendly name that describes the role of this service instance in the device.\n* ```\nconst [instanceName] = jdunpack<[string]>(buf, \"s\")\n```",
  "jacdac.SystemReg.Intensity": "Read-write uint32_t. This is either binary on/off (0 or non-zero), or can be gradual (eg. brightness of an RGB LED strip).\n* ```\nconst [intensity] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.MaxPower": "Read-write mA uint16_t. Limit the power drawn by the service, in mA.\n* ```\nconst [maxPower] = jdunpack<[number]>(buf, \"u16\")\n```",
  "jacdac.SystemReg.MaxReading": "Constant int32_t. The highest value that can be reported by the sensor.\n* ```\nconst [maxReading] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.MaxValue": "Constant int32_t. The highest value that can be reported for the value register.\n* ```\nconst [maxValue] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.MinReading": "Constant int32_t. The lowest value that can be reported by the sensor.\n* ```\nconst [minReading] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.MinValue": "Constant int32_t. The lowest value that can be reported for the value register.\n* ```\nconst [minValue] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.Reading": "Read-only int32_t. Read-only value of the sensor, also reported in streaming.\n* ```\nconst [reading] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.ReadingError": "Read-only uint32_t. The real value of whatever is measured is between `reading - reading_error` and `reading + reading_error`. It should be computed from the internal state of the sensor. This register is often, but not always `const`. If the register value is modified,\nsend a report in the same frame of the `reading` report.\n* ```\nconst [readingError] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.ReadingRange": "Read-write uint32_t. For sensors that support it, sets the range (sometimes also described `min`/`max_reading`).\nTypically only a small set of values is supported.\nSetting it to `X` will select the smallest possible range that is at least `X`,\nor if it doesn't exist, the largest supported range.\n* ```\nconst [readingRange] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.ReadingResolution": "Constant uint32_t. Smallest, yet distinguishable change in reading.\n* ```\nconst [readingResolution] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.StatusCode": "Reports the current state or error status of the device. `code` is a standardized value from\nthe Jacdac status/error codes. `vendor_code` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet.\n* ```\nconst [code, vendorCode] = jdunpack<[jacdac.SystemStatusCodes, number]>(buf, \"u16 u16\")\n```",
  "jacdac.SystemReg.StreamingInterval": "Read-write ms uint32_t. Period between packets of data when streaming in milliseconds.\n* ```\nconst [streamingInterval] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.StreamingPreferredInterval": "Constant ms uint32_t. Preferred default streaming interval for sensor in milliseconds.\n* ```\nconst [streamingPreferredInterval] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemReg.StreamingSamples": "Read-write # uint8_t. Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).\n* ```\nconst [streamingSamples] = jdunpack<[number]>(buf, \"u8\")\n```",
  "jacdac.SystemReg.SupportedRanges": "Constant. Lists the values supported as `reading_range`.\n* ```\nconst [range] = jdunpack<[number[]]>(buf, \"u32[]\")\n```",
  "jacdac.SystemReg.Value": "Read-write int32_t. The primary value of actuator (eg. servo pulse length, or motor duty cycle).\n* ```\nconst [value] = jdunpack<[number]>(buf, \"i32\")\n```",
  "jacdac.SystemReg.Variant": "Constant uint32_t. The hardware variant of the service.\nFor services which support this, there's an enum defining the meaning.\n* ```\nconst [variant] = jdunpack<[number]>(buf, \"u32\")\n```",
  "jacdac.SystemStatusCodes.Calibrating|block": "calibrating",
  "jacdac.SystemStatusCodes.CalibrationNeeded|block": "calibration needed",
  "jacdac.SystemStatusCodes.Initializing|block": "initializing",
  "jacdac.SystemStatusCodes.Ready|block": "ready",
  "jacdac.SystemStatusCodes.Sleeping|block": "sleeping",
  "jacdac.SystemStatusCodes.WaitingForInput|block": "waiting for input",
  "jacdac.loggerClient|block": "logger",
  "jacdac.loggerServer|block": "logger",
  "jacdac.roleManagerServer|block": "role manager",
  "jacdac.settingsServer|block": "settings",
  "jacdac|block": "jacdac",
  "modules|block": "modules",
  "{id:category}Control": "Control",
  "{id:category}Jacdac": "Jacdac",
  "{id:category}Modules": "Modules",
  "{id:category}Pins": "Pins",
  "{id:group}Roles": "Roles",
  "{id:group}Settings": "Settings"
}